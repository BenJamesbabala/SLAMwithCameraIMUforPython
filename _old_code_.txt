







				###############################
				if(self.count == 0): ###############################
					print("z "),
					print(z)
					print("h "),
					print(h)
					print("Hx"),
					print(H.dot(X.landmarks[landmarkId].mu))
				###############################





class Landmark:

	def __init__(self, id_, step_, index_):
		self.id = id_
		self.step = step_
		self.index = index_
		self.mu = np.array([0.0,0.0,0.0,0.0,0.0,0.0])
		self.sigma = np.zeros([])




		
	
	def findLandmark(self, step_, index_):
		if(step_ == -1):
			return "none"
			
		if(len(self.landmarks) == 0):
			return "none"
		
		for landmark in reversed(self.landmarks):
			if(landmark.step < step_):
				break
			if(landmark.step == step_ and landmark.index == index_):
				return landmark
		return "none"






	def f_IMU(self, X, dt, dt2, accel, ori, w_a):
		""" Transition model
		- 状態方程式
			x_t = f(x_t-1, u) + w
			w ~ N(0, sigma)
		"""
	
		#X_new = copy.deepcopy(X)
		X_new = Particle()
		X_new.landmarks = X.landmarks
	
		# Transition with noise (only x,v)
		#w_mean = numpy.zeros(3) # mean of noise
		#w_cov_a = numpy.eye(3) * self.noise_a_sys # covariance matrix of noise (accel)
		#w_a = numpy.random.multivariate_normal(w_mean, w_cov_a) # generate random
		
		X_new.x = X.x + dt*X.v + dt2*X.a + dt2*w_a
		X_new.v = X.v + dt*X.a + dt*w_a
		X_new.a = accel
		X_new.o = ori
	
		return X_new


	def f_camera(self, dt, X):
		""" Transition model
		- 状態方程式
			x_t = f(x_t-1, u) + w
			w ~ N(0, sigma)
		"""

		#X_new = copy.deepcopy(X)
		X_new = Particle()
		X_new.landmarks = X.landmarks

		dt2 = 0.5 * dt * dt
		
		# Transition with noise (only x,v)
		w_mean = numpy.zeros(3) # mean of noise
		w_cov_a = numpy.eye(3) * self.noise_a_sys # covariance matrix of noise (accel)
		w_a = numpy.random.multivariate_normal(w_mean, w_cov_a) # generate random
		
		X_new.x = X.x + dt*X.v + dt2*X.a + dt2*w_a
		X_new.v = X.v + dt*X.a + dt*w_a
		X_new.a = X.a
		X_new.o = X.o

		return X_new







	def predictionAndUpdateIMU(self, X, dt, accel, ori, M, noise_a_sys):
		print("start")
		queue = multiprocessing.Queue()
		jobs = []
		for Xlist in list(more_itertools.chunked(X, int(M/4))):
			job = multiprocessing.Process(target=worker_IMU, args=(queue, Xlist, dt, accel, ori, noise_a_sys))
			jobs.append(job)
			job.start()
		[j.join() for j in jobs]
		return [queue.get() for i in xrange(M)]




	def predictionAndUpdateIMU(self, X, X_predicted, dt, accel, ori, M, noise_a_sys):
		pool = mp.Pool(mp.cpu_count())
		results = [pool.apply_async(f_IMU, args=(Xi, dt, accel, ori, noise_a_sys)) for Xi in X]    
		output = [p.get() for p in results]
		pool.close()
		pool.join()
		return output






		start_time_ = time.clock() #####################
		end_time_ = time.clock() #####################
		print "time = %f" %(end_time_-start_time_) #####################




	#Set new data and Execute all functions
	def processData(self,data):

		#if nomatch then nothing to do
		if(data[0] == "nomatch"):
			#print("nomatch"),
			return

		keypoints = []
		for d in data:
			if(d != ''):
				keypoints.append(KeyPoint(d))




		##############################
		print("----------------")
		for k in keypointPairs:
			print(k.x1),
			print(k.y1),
			print(" -> "),
			print(k.x2),
			print(k.y2)
		##############################




		##################################
		# print variance of x
		print(self.sigma[0][0]),
		print(self.sigma[1][1]),
		print(self.sigma[2][2])
		dt2 = 0.5 * 0.02 * 0.02
		w_mean = np.zeros(3) # mean of noise
		w_cov_a = np.eye(3) * self.PFnoise_a_sys # covariance matrix of noise (accel)
		w_a = np.random.multivariate_normal(w_mean, w_cov_a) # generate random
		print(dt2*w_a)
		##################################



		# ----- Set parameters here! ----- #
		self.M = 100 # total number of particles パーティクルの数
		self.f = 1575.54144 # focus length of camera [px] カメラの焦点距離 [px]
		# Kalman Filter
		self.noise_a_sys = 0.01 # system noise of acceleration　加速度のシステムノイズ
		self.noise_g_sys = 0.01 # system noise of gyro　ジャイロのシステムノイズ
		self.noise_a_obs = 0.00000001 # observation noise of acceleration　加速度の観測ノイズ
		self.noise_g_obs = 0.00000001 # observation noise of gyro　ジャイロの観測ノイズ
		# Particle Filter
		self.PFnoise_a_sys = 5.0 # system noise of acceleration　加速度のシステムノイズ
		self.PFnoise_g_sys = 5.0 # system noise of gyro　ジャイロのシステムノイズ
		self.PFnoise_a_obs = 0.00000001 # observation noise of acceleration　加速度の観測ノイズ
		self.PFnoise_g_obs = 0.00000001 # observation noise of gyro　ジャイロの観測ノイズ
		self.PFnoise_coplanarity_obs = 0.1 # observation noise of coplanarity 共面条件の観測ノイズ
		# ----- Set parameters here! ----- #





		# count
		self.count += 1
		print(self.count),



		coplanarity_matrix = range(M) ########################

		############################
		print(coplanarity_matrix[0][0]),
		print(coplanarity_matrix[0][1]),
		print(coplanarity_matrix[0][2])
		############################







			##################################
			# print variance of x
			print("IMU"),
			print(self.sigma[0][0]),
			print(self.sigma[1][1]),
			print(self.sigma[2][2])
			# print variance of a
			#print("IMU"),
			#print(self.sigma[6][6]),
			#print(self.sigma[7][7]),
			#print(self.sigma[8][8])
			##################################

		##################################
		# print variance of x
		print("Camera"),
		print(self.sigma[0][0]),
		print(self.sigma[1][1]),
		print(self.sigma[2][2])
		# print variance of a
		#print("Camera"),
		#print(self.sigma[6][6]),
		#print(self.sigma[7][7]),
		#print(self.sigma[8][8])
		##################################





		###################
		print("====================")
		for X_ in self.X:
			print(X_.x[0]),
			print(X_.x[1]),
			print(X_.x[2])
		print("====================")
		###################

		###################
		print("------------------------")
		for X_ in self.X:
			print(X_.x[0]),
			print(X_.x[1]),
			print(X_.x[2])
		print("------------------------")
		###################
